<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.424">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Generating Correlated Data for Omics Simulation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="paper_files/libs/clipboard/clipboard.min.js"></script>
<script src="paper_files/libs/quarto-html/quarto.js"></script>
<script src="paper_files/libs/quarto-html/popper.min.js"></script>
<script src="paper_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="paper_files/libs/quarto-html/anchor.min.js"></script>
<link href="paper_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="paper_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="paper_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="paper_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="paper_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#comparison-to-real-data" id="toc-comparison-to-real-data" class="nav-link" data-scroll-target="#comparison-to-real-data">Comparison to Real Data</a></li>
  <li><a href="#deseq2-application" id="toc-deseq2-application" class="nav-link" data-scroll-target="#deseq2-application">DESeq2 Application</a></li>
  <li><a href="#cyclops-application" id="toc-cyclops-application" class="nav-link" data-scroll-target="#cyclops-application">CYCLOPS Application</a></li>
  </ul></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Generating Correlated Data for Omics Simulation</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>Simulation of realistic omics data is a key input for benchmarking studies that help users obtain optimal computational pipelines. Omics data involves large numbers of measured features on each samples and these measures are generally correlated with each other. However, simulation too often ignores these correlations, perhaps due to the inconvenience and computational hurdles of doing so. We describe two approaches to solving this problem that are simple to implement and computationally very fast, both of which work by decomposing the covariance matrix into a diagonal part and a low-rank part. We demonstrate the importance of including correlation in two benchmarking applications. First, we show that variance of results from the popular DESeq2 method increases when dependence is included. Second, we demonstrate that a method, CYCLOPS, for inferring circadian time of collection from transcriptomics actually improves its performance when dependence is included. We provide an R package, dependentsimr, that has efficient implementations of these methods and can generate dependent data with arbitrary distributions, including discrete (binary, ordered categorical, Poisson, negative binomial), continuous (normal), or with an empirical distribution.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Omics data is in the “p &gt;&gt; n” regime where there are fewer samples than measurements per sample. This creates dual challenges in generating realistic simulated data for the purposes of benchmarking. First, there isn’t enough data to be able to compute a dependence structure (e.g., a full-rank correlation matrix). Second, generating omics-scale data with a specified correlation matrix is slow due to the typical <span class="math inline">\(O(p^3)\)</span> nature of these algorithms. These often mean that simulators assume independence of the measurements, which does not reflect reality.</p>
<p>Recently, we wrote guidelines for performing omics benchmarking <span class="citation" data-cites="Brooks2024">(<a href="#ref-Brooks2024" role="doc-biblioref">Brooks et al. 2024</a>)</span> and encouraged authors to ensure that any simulated data includes realistic correlation and dependence of measurements within a sample. However, this highlighted that one reason this is often neglected is that there is relatively little guidance for how to achieve it and that existing solutions are cumbersome.</p>
<p>Here, we give a simple solution this problem by using a correlation matrix that decomposes into a diagonal part and a low-rank part to both approximate realistic dependencies in a real data set and generate simulated data mimicking the real data. Using a NORTA (Normal to Anything) approach, the marginal (univariate) distributions can have realistic forms. We implement this strategy as an R package which supports normal, Poisson, DESeq2-based (negative binomial with sample-specific size factors), and empirical (for ordinal data) marginal distributions. This makes it particularly suited to RNA-seq data but also widely applicable.</p>
<p>We show two applications which demonstrate the importance of including dependence of measurements in simulated data when benchmarking computational pipelines. First, we simulate RNA-seq data with differential expression between two conditions. Using DESeq2 to determine the differentially expressed genes, we found that dependence had little impact on the accuracy of reported p-values but increased the variance of those estimates, meaning that experiments simulated with dependence were more likely to be conservative and more likely to be anti-conservative compared to simulations of independent data. Second, we simulated a time series of RNA-seq data points and used the CYCLOPS method to infer collection time from the RNA-seq data, without time labels. Surprisingly, we found that including dependence in the data set resulted in improved performance with CYCLOPS.</p>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<section id="comparison-to-real-data" class="level3">
<h3 class="anchored" data-anchor-id="comparison-to-real-data">Comparison to Real Data</h3>
<p>We used mouse liver RNA-seq data set from accession GSE77221<span class="citation" data-cites="Weger2019">(<a href="#ref-Weger2019" role="doc-biblioref">Weger et al. 2019</a>)</span> where we expected a significant amount of gene-gene correlation due to the samples having been collected throughout the course of a day. We used this data to prime our simulation and compared real and simulated data sets, both with 12 samples, to each other. We repeated the simulations a total of 8 times to estimate variance. The simulations were then repeated without any dependence for comparison.</p>
<p>Simulated data captures the genes’ mean and variance accurately (<a href="#fig-compare-to-real" class="quarto-xref">Figure&nbsp;1</a> a-b). Moreover, we computed the gene-gene correlation on a random subset of 3000 high-expressed genes. Since only 12 samples are in each real or simulated data set, correlation estimates are very noisy. However, the distribution of correlations across all pairs of these genes is much closer to that of real data when simulated with dependence than without (<a href="#fig-compare-to-real" class="quarto-xref">Figure&nbsp;1</a> c).</p>
<p>Next, we compared the simulations with and without dependence to the real data set when projected onto the top two principal components of the real data set (<a href="#fig-compare-to-real" class="quarto-xref">Figure&nbsp;1</a> d). The simulations with dependence are distributed around the entire space like the real data, but the independent simulations have unrealistically low variance in these components, clustering tightly around the origin. Lastly, we compared the PCA of each simulated data set considered separately from the real data. Simulations with independent data showed unrealistically low levels of variance in top principal components, but dependent simulations actually show too high elevations of variance in top components. This is a consequence of our PCA strategy: since variance in the direction of the real data set’s top principal component is exactly matched, the simulated data set’s top principal component will be even larger than that.</p>
<div class="cell" data-hash="paper_cache/html/fig-compare-to-real_1d8746f5f66b3ae77b70334163062cce">
<div class="cell-output-display">
<div id="fig-compare-to-real" class="quarto-figure quarto-figure-center anchored" width="960">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-compare-to-real-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="paper_files/figure-html/fig-compare-to-real-1.png" class="img-fluid figure-img" width="960">
</div>
<figcaption class="figure quarto-float-caption quarto-float-fig" id="fig-compare-to-real-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Comparison to real data run on a mouse liver example from GSE77221. (a-b) Comparison of gene (a) mean expression and (b) variance, log-scaled. The line of equality is marked in black. Points are colored according to the density of points in their region. (c) Quantile-quantile plot comparing correlation values of gene pairs from real data and simulated data (both with and without dependence). A random sample of 3000 genes with at least 300 reads was used. Values on the diagonal line indicate a match between the simulated and real data sets. (d) Projections onto the top two principal components of the real data set for both real and simulated data. All 8 simulations (96 samples total for each of dependent and independent simulations) shown. (e) Principal component analysis was performed on all data sets and the variance captured by the top components is shown. Unlike (d), these components were fit from each data set considered separately instead of reusing the weights from the real data.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="deseq2-application" class="level3">
<h3 class="anchored" data-anchor-id="deseq2-application">DESeq2 Application</h3>
<p>We benchmark DESeq2, a popular differential expression analysis tool, using data sets simulated with dependence and ones simulated without dependence to compare its performances on both. We use a fly whole body RNA-Seq data set GSE81142 and select samples of male flies without treatment and after at least 2 hours of feeding to simulate 20 control samples with rank <span class="math inline">\(k=2\)</span> dependence structure, and 20 control samples assuming independence of the genes. We then randomly select 5% of the genes to be up or down regulated, with <span class="math inline">\(\log_2\)</span> fold change uniformly distributed between <span class="math inline">\(0.2\)</span> and <span class="math inline">\(2.0\)</span>, and simulate 20 “experimental” samples each with and and without dependence.</p>
<p>Finally, we run DESeq2 on the two simulated experiments and compare the output false discovery rate (FDR) with the true percentages of genes that are differential expressed (<a href="#fig-DESeq2" class="quarto-xref">Figure&nbsp;2</a> a-b). We observe that DESeq2 is slightly anti-conservative on both data sets, with similar mean true FDRs for each estimated FDR cutoff. However, there is a greater variance in the performance of DESeq2 on the data sets simulated with dependence, indicating that it potentially performs less reliably on data sets with gene-gene dependence, as in real data sets. We speculate that this is due to DESeq2’s assumption that the gene expressions are independent.</p>
<p>To demonstrate the application of our simulation method for another organism, we also simulate data sets using a mouse cortex data set GSE151923 and select samples from male mice to infer the dependence structure of the quantified genes. We then simulate differential expression experiments with and without dependence as above, with 20 samples for each condition. We observe a similar result (<a href="#fig-DESeq2" class="quarto-xref">Figure&nbsp;2</a> c-d) as for the fly whole body data sets.</p>
<div class="cell" data-hash="paper_cache/html/fig-DESeq2_0c09080b37fe5bb70d790a67937c6312">
<div class="cell-output-display">
<div id="fig-DESeq2" class="quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-DESeq2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="paper_files/figure-html/fig-DESeq2-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="figure quarto-float-caption quarto-float-fig" id="fig-DESeq2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Performance of DESeq2 on simulated datasets. (a-b) Comparison of true FDR and DESeq2 reported FDR for data sets simulated from the fly whole body data set (GSE81142), (a) without dependence and (b) with dependence. (c-d) Comparison of true FDR and DESeq2 reported FDR for data sets simulated from the mouse cortex data set (GSE151923, Wang et al.&nbsp;2022), (c) without dependence and (d) with dependence.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="cyclops-application" class="level3">
<h3 class="anchored" data-anchor-id="cyclops-application">CYCLOPS Application</h3>
<p>We further use our simulation method to benchmark CYCLOPS (Anafi et al.&nbsp;2017), which infer relative times for a set of unlabeled samples using an autoencoder to identify circular structures. We use a mouse liver time series data set (GSE151565, Aaronson et al.&nbsp;2020), which contains a total of 77 samples every 3 hours, for 36 hours. We compute the dependence structure of the genes as well as the variances of marginal distributions using the 12 time point 0 samples, and compute the means of gene expressions at each time point. We then use these to simulate 20 time series data sets with rank <span class="math inline">\(2\)</span> dependence structure, each with 8 time points and 6 samples per time point, and 20 such data sets without dependence.</p>
<p>We run CYCLOPS on each data set with a list of cyclic mouse liver genes (JTK p-value <span class="math inline">\(&lt;0.05\)</span>), which yields an estimated relative time for each sample. For the evaluation metric for CYCLOPS’ performance, we use the circular correlation, defined as follows: <span class="math display">\[\rho = \frac{\sum_{1\leq i&lt;j\leq n}sin(X_i-X_j)sin(Y_i-Y_j)}{(\sum_{1\leq i&lt;j\leq n}sin(X_i-X_j)^2)^{1/2}(\sum_{1\leq i&lt;j\leq n}sin(Y_i-Y_j)^2)^{1/2}},\]</span> where <span class="math inline">\(n\)</span> is the number of samples, <span class="math inline">\(X_i\)</span> and <span class="math inline">\(Y_i\)</span> are the true time and CYCLOPS-estimated time respectively for the <span class="math inline">\(i\)</span>-th sample. <span class="math inline">\(\rho\)</span> has value between <span class="math inline">\(-1\)</span> and <span class="math inline">\(1\)</span>, and a <span class="math inline">\(|\rho|\)</span> close to <span class="math inline">\(1\)</span> indicates accurate predictions by CYCLOPS.</p>
<p>We find that CYCLOPS performs better overall on simulated time series data sets with dependence than on those without dependence (<a href="#fig-CYCLOPS" class="quarto-xref">Figure&nbsp;3</a>), indicating that the presence of gene-gene dependence is essential for CYCLOPS’ performance.</p>
<div class="cell" data-hash="paper_cache/html/fig-CYCLOPS_f68112debd92032912fa22bd83cd5d02">
<div class="cell-output-display">
<div id="fig-CYCLOPS" class="quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-CYCLOPS-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="paper_files/figure-html/fig-CYCLOPS-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="figure quarto-float-caption quarto-float-fig" id="fig-CYCLOPS-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Performance of CYCLOPS on simulated time series data sets based on mouse liver data set (GSE151565, Aaronson et al.&nbsp;2020). (a) Violin plot comparing absolute circular correlations between true phases and CYCLOPS estimated phases on the simulated data sets with and without dependence. (b-c) Examples of CYCLOPS estimated phases on a simulated data set (b) without dependence and (c) with dependence.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<p>TODO: how it works</p>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>We present <code>dependentsimr</code>, an R package that generates omics-scale data with realistic correlation. TODO: limitations TODO: alternatives</p>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Brooks2024" class="csl-entry" role="listitem">
Brooks, Thomas G., Nicholas F. Lahens, Antonijo Mrčela, and Gregory R. Grant. 2024. <span>“Challenges and Best Practices in Omics Benchmarking.”</span> <em>Nature Reviews Genetics</em> 25 (5): 326–39. <a href="https://doi.org/10.1038/s41576-023-00679-6">https://doi.org/10.1038/s41576-023-00679-6</a>.
</div>
<div id="ref-Weger2019" class="csl-entry" role="listitem">
Weger, Benjamin D., Cédric Gobet, Jake Yeung, Eva Martin, Sonia Jimenez, Bertrand Betrisey, Francis Foata, et al. 2019. <span>“The Mouse Microbiome Is Required for Sex-Specific Diurnal Rhythms of Gene Expression and Metabolism.”</span> <em>Cell Metabolism</em> 29 (2): 362–382.e8. <a href="https://doi.org/10.1016/j.cmet.2018.09.023">https://doi.org/10.1016/j.cmet.2018.09.023</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>